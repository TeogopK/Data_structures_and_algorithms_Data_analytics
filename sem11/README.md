# Упражнение 11

# Хештаблица

## Миналия път правихме

- Упражнение върху задачи

## Въпроси от миналия път/ контролното

- :)

Решения от [контролно 4](https://www.hackerrank.com/sda-2023-2024-test4-ad) - [тук](https://github.com/TeogopK/SDA-solved/tree/main/Exams/exam_04).

## Днес ще разгледаме

- Хештаблица (Hashtable)
- Справяне с колизии
- Структури в Python, които са имплементирани чрез хештаблица

## Hashtable (Хештаблица)

Основната идея на хештаблицата е да се възползваме от бързия достъп до последователна памет (като например при списъка). За да е възможно това обаче, трябва да имаме начин да транслираме нашите обекти до цели положителни числа. Например ако имаме низ "abd", то той може лесно да бъде хеширан до цяло положително число, ако просто на всеки символ съпоставим по едно число ("a" -> 1, "b" -> 2, "d" -> 4) и ги съберем, тогава нашият низ ще се хешира до стойността 7. Но ако низът ни е "bad", то той ще има същата хеш стойност, което води до колизия, за които ще говорим по-нататък. Това, което направихме по-горе (да сведем стринг до цяло число) е всъщност работата на хеш функциите. Ето и какви са характеристиките на хеш функциите:
1) Да бъдат бързи за изчисление.
2) Да създават по възможност минимален брой колизии, справянето с колизиите увеличава средното време за изпълнението на заявки към струткурата от данни.
3) Когато хешираме един и същи обект, винаги да връща една и съща стойност, тоест да няма елемент на случайност или някакво състояние, което да повлияе на резултата от функцията (stateless).

## Справяне с колизии
Колизиите са неизбежна част от хеширането и това са случаите, когато два различни обекта имат една и съща хеш стойност, след като биват прекарани през хеш функцията. Ще разгледаме 3 начина за справяне с колизии. 

### Separate chaining
Това е най-популярният метод за справяне с колизии. След като придадем цяло число на нашия обект и то се окаже, че вече имаме запис със същото цяло число, то тогава двата обекта се нареждат в свързан списък, в който след това търсенето бива линейно. Използва се свързан списък, защото бързо се добавя елемент в края и премахва елемент от средата.

### Linear Probing
Това е по-рядко срещан метод, при който ако нашия обект се хешира до дадено цяло число x, но то вече е заето, то тогава ще бъде попълнено първото число > x, което е свободно. Ако например нашият обект се хешира до числото 5 и то е заето, то тогава започваме да търсим в 6, в 7 и т.н.

### Double Hashing
За да направим двойно хеширане, ни трябват 2 хеширащи функции, през които да прекараме нашия обект. В този случаи намаляме шанса за колизии значително, но разбира се това не ни гарантира на 100%, че такива няма да има. Поради тази причина той също е рядко срещан.

## Имплементации в Python

2 са основните стурктури в python, които са имплементирани чрез хештаблица. Едната от тях е set, която репрезентира множество, в което всеки елемент е хеширан и съответно бързо (за константно време), може да извършва операциите:
1) Да провери дали съществува даден елемент в множество.
2) Да добавим елемент в множеството.
3) Да премахнем елемент в множеството.
4) Да вземем броя на елементите в множеството.

Освен set, другата структура от данни е dictionary, която е аналогична на set-a, но с тази разлика, че се състои от ключове, които сочат към стойности (ще видим примери в playground-a) и ключовете биват хеширани, тоест отговарят на горепосочените характеристики на set-a.

Примери за използването на хештаблица в [playground-а](playground_11.ipynb).

## Задачи за упражнение

- [K-diff Pairs in an Array](https://leetcode.com/problems/k-diff-pairs-in-an-array)
- [Group Anagrams](https://leetcode.com/problems/group-anagrams)
- [Repeated DNA Sequences](https://leetcode.com/problems/repeated-dna-sequences)
- [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence)
- [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k)
- [0-1 Subarray](https://www.hackerrank.com/contests/sda-homework-9/challenges/0-1-1)

Решения на задачите: [тук](https://github.com/TeogopK/SDA-solved/tree/main/Seminar/sem_11)